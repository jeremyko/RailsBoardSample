Ruby on Rails 간단 게시판 - 1

(rails 에 관심있는 새내기에 의한, 새내기를 위한 글 입니다~~).

요즘 취미로 Ruby on Rails 에 대해 공부하고 있는데, Teaching is Learning 이라고 했던가?
강좌 형식을 빌어 간단한 게시판 예제를 가지고 정리 해보기로 했다

이 예제의 소스는 여기서 받을수 있다.
https://github.com/jeremyko/RailsBoardSample

우리가 만들 게시판은 앞서 spring, django 에서 예제로 만든것 과 동일한 기능의 게시판이다. 간단한 기능을 가진 게시판이라서, Rails가 제공해주는 scaffolding 을 사용하면 10분 이내로도 작성이 가능할 수 있겠지만, 이 예제에서는 scaffolding 을 사용하지 않고 처음부터 작성하는것으로 한다. 그리고 Rails 에서 가능한 여러 기능들 즉, RSpec을 사용한 BDD, REST지원, validation check, coffee script, 뷰에서의 partial 등은 일단 간단 게시판을 먼저 작성한후, 향후 포스팅을 통해서 점차 적용시켜보도록 할것이다.

rails와 ruby 개발 환경은 완료된 상태라고 가정한다.
이 예제에서의 사용된 개발환경은 다음과 같다.
ruby 1.9.3p194 (2012-04-20) [i386-mingw32]
Rails 3.2.8

그리고 사용할 DB는 기본 Sqlite 로 하기로 한다.
만약, Oracle 사용시에는 그에 따른 약간의 소스 코드 수정이 필요한데, 그것은 주석으로 표시하였다.



* rails application 생성

적정한 폴더상에서 다음 명령을 수행해서 새로운 rails application을 생성한다.

rails new RailsBoard

rails는 디렉토리 구조를 생성하고, 자동적으로 bundle install 명령을 수행하여
필요한 gem들을 설치한다.

* Gemfile 및 database.yml

이 예제에서는 그냥 sqlite3 을 사용할것이므로 특별히 수정할 필요가 없다.

그런데, 만약 oracle을 사용하고 싶다면, 다음을 참고해서 두 파일의 내용을 변경하기 바란다.
http://jeremyko.blogspot.kr/2012/08/windows-ruby-on-rails-ror-oracle-xe-11g.html


* 컨트롤러 및 뷰 작성

Rails의 MVC pattern의 흐름을 간단하게 살펴보면,

1. 브라우져의 요청은 rails에 의해 특정 컨트롤러의 메서드로 route 되어진다.

2. 해당 컨트롤러에서는 요청을 모델로 전달한다.

3. 해당 모델은 요청에 따라 데이터베이스에 대한 작업(조회,생성,변경,삭제등)을 수행하고,
   필요한 경우 데이터를 리턴한다.( 예를 들어서 조회)

4. 컨트롤러는 모델로부터 데이터를 받아서 .html.erb의 확장자를 가지는 뷰로 전달한다.

5. 해당 뷰에서는 erb(embedded ruby)를 이용해서 html 형식으로 렌더링한후, 컨트롤러로 리턴한다.

6. 컨트롤러는 이 html결과를 클라이언트(브라우져)에게 돌려주게 된다.

만약 컨트롤러의 메서드에서 아무런 작업을 하지 않는 경우라면 어떻게 처리가 될까?
그렇더라도 연관된 해당 뷰는 항상 호출이 된다 (즉 이런 경우는 정적인 페이지 처리가 된다).

간단한 예제를 빨리 만들어보기 위해서, 이 예제에서는 여러개의 컨트롤러를 사용하지는 않을 것이다. 게시판 기능을 위한 BoardController 하나를 작성하고 그 내부에는 게시판 기능에 대한 요청을 처리할 메서드를 정의할것이다.(이 메서드를 action 이라고도 한다).

게시판 기능을 위한 컨트롤러를 board라고 하고, 처음 화면을 위한 action은 index 라고 한다면, rails g (generate) 명령을 사용하여, 컨트롤러 및 액션, 뷰까지 한번에 생성 가능하다.

rails g controller board index

board 컨트롤러를 생성하면서, index Action(메서드)도 같이 생성했다.
그럼 동시에, 이에 대한 뷰도 자동으로 생성이 되는데, 바로 RailsBoard\app\views\board\index.html.erb 이다.
뷰의 이름은 action의 이름과 동일하게 생성이 된다. erb 는 embedded ruby 를 나타낸다.

* route 지정

RailsBoard\config\routes.rb 에 방금 추가한 컨트롤러,action을 url에 mapping 해줘야 한다.

먼저 route.rb 에서 get "board/index" 는 주석 처리한다.
# get "board/index"

그리고 root :to =>... 부분을 다음처럼 수정한다.
root :to => 'board#index'

이제 사이트의 root가 board 컨트롤러의 index action으로 설정이 되었다.


* Model 작성

다음에 해야할일은 데이터베이스 작업을 위한 모델을 정의하는 것이다.
게시판 데이터를 저장하기 위해서 먼저 생각해본 스키마는 다음과 같다.
(이번에도, 간단한 예제작성을 위해 테이블 하나만 사용하기로 한다)

"SUBJECT" : 제목 (text)
"NAME" : 이름 (text)
"MAIL" : 메일 (text)
"MEMO" : 게시물 내용 (text)
"HITS" : 조회수 (integer)

이 스키마를 기초로, 모델을 생성하기 위해 다음을 수행한다.

rails g model MyRailsBoardRow subject:string name:string mail:string memo:string hits:integer

성공적으로 수행이 되면, 그 결과로 \RailsBoard\db\migrate 폴더 및 폴더 내부에는 migration 파일이 생성된다. (실제 DB 생성/변경이 발생하는것은 아니다)

class CreateMyRailsBoardRows < ActiveRecord::Migration
    def change
        create_table :my_rails_board_rows do |t|
     t.string :subject
     t.string :name
     t.string :mail
     t.string :memo
     t.integer :hits

      t.timestamps
        end
    end
end

이처럼, DB구조에 변경이 발생할때마다 migration파일을 먼저 생성해야 한다.
이를 통해 우리는 DB를 점진적으로 변경할수 있게 된다. 아울러 변경 이력도 관리 가능하다.

흥미로운 것은 Rails가 만들어준 이름이다. 모델 이름을 단수(MyRailsBoardRow)로 정의했는데, Rails에서는 이것을 복수(CreateMyRailsBoardRows)로 자동으로 변환해서
테이블 생성 메서드를 정의해 준다. 곰곰 생각해보면 이러한 명명법이 말이 된다.
데이터베이스는 집합이므로 즉 복수.. 내가 생성한 모델은 그 집합을 이루는 각각의 요소 하나, 즉 단수..

이제, 이 마이그레이션을 실제 DB에 반영하기 위해서는 다음 명령을 수행한다.

bundle exec rake db:migrate

성공적으로 수행이 되었다면, 실제 생성된 테이블은 다음과 같다.

# SQLITE3 경우
CREATE TABLE "my_rails_board_rows"
("id" INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
"subject" varchar(255),
"name" varchar(255),
"mail" varchar(255),
"memo" varchar(255),
"hits" integer,
"created_at" datetime NOT NULL,
"updated_at" datetime NOT NULL);

# 오라클 경우
CREATE TABLE  "MY_RAILS_BOARD_ROWS"
( "ID" NUMBER(38,0) NOT NULL ENABLE,
 "SUBJECT" VARCHAR2(255 CHAR),
 "NAME" VARCHAR2(255 CHAR),
 "MAIL" VARCHAR2(255 CHAR),
 "MEMO" VARCHAR2(255 CHAR),
 "HITS" NUMBER(38,0),
 "CREATED_AT" DATE NOT NULL ENABLE,
 "UPDATED_AT" DATE NOT NULL ENABLE,
  PRIMARY KEY ("ID") ENABLE  ) ;

실제로 테이블이 생성되었는지 확인해 본다.

* 컨트롤러 구현

이제 생성된 컨트롤러에 action을 구현해야 할 차례이다.

먼저 좀 해줘야 할 것이 있는데,컨트롤러들에서 사용할 rowsPerPage 전역 변수를 위해
\RailsBoard\app\controllers\application_controller.rb 파일에 다음처럼 추가한다.

class ApplicationController < ActionController::Base
    protect_from_forgery
    # rowsPerPage 한 페이지당 표시될 게시물 수
    # 모든 컨트롤러에서 사용가능하게 여기에 정의한다.
    def rowsPerPage
        @rowsPerPage ||= 2
    end
end

그리고, 게시물의 페이지처리라던지, 웹페이지의 타이틀 변경같은 몇몇 공통기능 구현을 위해서 ApplicationHelper module에 정의할것이 있다.
\RailsBoard\app\helpers\application_helper.rb 파일을 다음 처럼 수정해준다.


module ApplicationHelper
    #--------------------------------------------------------------------------#
    # title 표시
    def full_title(page_title)
        base_title = "RailsBoard"
        if page_title.empty?
            base_title
        else
            "#{base_title} | #{page_title}"
        end
    end

    #--------------------------------------------------------------------------#
    # Paging helper
    def getTotalPageList( total_cnt, rowsPerPage )
        if ((total_cnt % rowsPerPage) == 0)
            total_pages = total_cnt / rowsPerPage;
        else
            total_pages = (total_cnt / rowsPerPage) + 1;
        end

        totalPageList = (1..total_pages).to_a
        #totalPageList = Array (1..total_pages)
    end
end


이제 컨트롤러 action을 구현해본다.
\RailsBoard\app\controllers\board_controller.rb 파일에 index action을 추가한다.
이 action이 최초 루트 페이지인, 게시판 전체 목록을 보여주는 화면을 처리한다.

class BoardController < ApplicationController
    # 모든 helper는 view에서는 사용가능하지만 controller 에서는 명시적으로
    # include 해줘야 한다.
    include ApplicationHelper

    #--------------------------------------------------------------------------#
    def index
        @boardList = MyRailsBoardRow.find(:all, :limit =>rowsPerPage, :order=>'created_at desc')  #(1)
        @totalCnt = MyRailsBoardRow.all.count   #(2)
        @current_page = 1        #(3) 최초 화면이므로 1
        @totalPageList = getTotalPageList(@totalCnt, rowsPerPage) #(4)
    end
end

이코드를 살펴보면,

(1) 모델(MyRailsBoardRow)을 사용해서 rowsPerPage 개만 조회해서 리스트를 돌려준다.
(2) 전체 게시물 갯수를 구하고
(3) 현재 페이지 변수를 설정하고 (루트 페이지이므로 1을 설정)
(4) ApplicationHelper mixin 의 getTotalPageList를 호출해서 전체 페이지 목록을 구한다.

그리고 이러한 @로 시작되는 instance 변수들은 자동적으로 뷰(RailsBoard\app\views\board\index.html.erb) 에서도 사용가능하다.


* 뷰 작성

컨트롤러가 모델을 사용해서, 데이터를 조회한후, 그 리스트를 돌려주었다. 이제 이 리스트를 화면에 출력하기 위해 뷰를 작성해야 한다. 이 화면이 최초 보여지는 전체 게시물 출력 화면이다. RailsBoard\app\views\board\index.html.erb 를 다음처럼 수정한다.

<table cellspacing=1 width=700 border=0>
    <tr>
        <td>총 게시물수: <%= @totalCnt %></td>
        <td><p align=right> 페이지:<%= @current_page %>
        </td>
    </tr>
</table>

<table cellspacing=1 width=700 border=1>
    <tr>
        <td width=50><p align=center>번호</p>
        </td>
        <td width=100><p align=center>이름</p>
        </td>
        <td width=320><p align=center>제목</p>
        </td>
        <td width=100><p align=center>등록일</p>
        </td>
        <td width=100><p align=center>조회수</p>
        </td>
    </tr>

    <% if @boardList.count > 0 %>
        <ul>
            <%  @boardList.each do |boardRow| %>
            <tr>
            <td width=50><p align=center><%= boardRow.id %></p></td>
            <td width=100><p align=center><%= boardRow.name %></p></td>
            <td width=320>
                <p align=center>
                    <a href="/viewWork?id=<%=boardRow.id%>&current_page=<%= @current_page %>&searchStr=None" title="<%= boardRow.memo%>"><%= boardRow.subject %>
                </p>
            </td>
            <td width=100><p align=center><%= boardRow.created_at %></p></td>
            <td width=100><p align=center><%= boardRow.hits %></p></td>
            </tr>
            <% end %>
        </ul>
    <% else %>
        <p>No Data.</p>
    <% end %>
</table>

<table cellspacing=1 width=700 border=1 >
    <tr>
        <td>
        <%  @totalPageList.each do |page| %>
            <a href="/listSpecificPageWork?current_page=<%=page%>" >
            [
            <% if page == @current_page.to_i %>
                <b>
            <% end %>

            <%=page%>

            <% if page == @current_page.to_i %>
                </b>
            <% end %>
            ]
         <% end %>
        </td>
    </tr>
</table>

<table width=700>
    <tr>
        <td><input type=button value="글쓰기"  OnClick="window.location='/show_write_form'" >  </td>
        <td><form name=searchf method=post action="/searchWithSubject/">
            <p align=right><input type=text name=searchStr size=50  maxlength=50>
            <input type=submit value="글찾기"></p>
        </td>
    </tr>
</table>

뷰에서 컨트롤러의 정보를 참조하는 방법을 살펴보면 된다.

* Test

이 뷰가 출력되기 위해서는 한가지 꼭 해줄것이 있는데, 다음 파일을 delete해주는 것이다.

public/index.html

rails가 기본적으로 출력하는 이것을 삭제해야, 내가 정의한 뷰가 보여진다.

이제 작성한 컨트롤러와 뷰가 제대로 동작하는지 확인하기 위해서,
어플리케이션 폴더상에서 다음을 실행해서 서브를 띄운다.

rails s

그리고 http://localhost:3000/ 으로 확인해본다.




Ruby on Rails 간단 게시판 - 2

이제 글쓰기 기능을 구현할 차례이다.
새로운 기능들을 추가하기위해서는 다음과 같은 일정한 절차를 반복해주면 된다.
1.url을 컨트롤러의 action에 mapping
2.action을 구현
3.해당 뷰를 구현.

그럼, 글쓰기를 위한 url, /show_write_form 을 컨트롤러의 action에 mapping 해보자.
RailsBoard\config\routes.rb 에 다음처럼 mapping 해준다.

RailsBoard::Application.routes.draw do
    root :to => 'board#index'
    # 컨트롤러와 action을 mapping
    match '/show_write_form',  to: 'board#show_write_form'
end

그리고, action을 구현한다.
\RailsBoard\app\controllers\board_controller.rb 파일에 show_write_form action을 추가한다.

class BoardController < ApplicationController
    include ApplicationHelper
    def index
        @boardList = MyRailsBoardRow.find(:all, :limit => rowsPerPage, :order=> 'created_at desc')
        @totalCnt = MyRailsBoardRow.all.count
        @current_page = 1
        @totalPageList = getTotalPageList(@totalCnt, rowsPerPage)
    end

    def show_write_form
    	#입력폼만을 풀력할것이므로 여기서는 처리할것이 없다.
    	# 그러나 만약 RESTful을 적용한다면, 여기서 model객체를 생성해서 전달하고, 데이터를 담아올것이다.
        # @rowData = MyRailsBoardRow.new => RESTful 처리시..
    end
end

#=> RESTful 처리시..
#컨트롤러의 instance variable은 뷰에서도 사용가능하다.
#그러므로, 뷰에서 새로운 게시물 정보를 받아오기 위해
#모델 객체를 생성해서 (MyRailsBoardRow.new) instance variable, @rowData에 저장한다.
#이 변수가 뷰에서 새로운 정보들을 받아오기 위해서 사용될것이다.

이제, 뷰를 생성해야 한다.
\RailsBoard\app\views\board\ 에 새로운 파일, show_write_form.html.erb 를 생성하고 내용은 다음처럼 작성해준다.

<% provide(:title, '게시판 글쓰기') %>

<script language="javascript">
    function writeCheck() {
        var form = document.writeform;

        if (!form.name.value)
        {
            alert("이름을 적어주세요");
            form.name.focus();
            return;
        }
        if (!form.subject.value) {
            alert("제목을 적어주세요");
            form.subject.focus();
            return;
        }
        if (!form.memo.value) {
            alert("내용을 적어주세요");
            form.memo.focus();
            return;
        }

        form.submit();
    }
</script>

<table width=700 border=1 cellspacing=0 cellpadding=5>
<form name=writeform method=post action="/DoWriteBoard">
<tr><td><b>이름</b></td><td><input type=text name=name size=50  maxlength=50></td></tr>
<tr><td><b>이메일</b></td><td><input type=text name=mail size=50  maxlength=50></td></tr>
<tr><td><b>제목</b></td><td><input type=text name=subject size=50  maxlength=50></td></tr>
<tr><td><b>내용</b></td><td><textarea name=memo cols=50 rows=10></textarea></td></tr>
</form>
</table>

<table width=700 border=1 cellspacing=0 cellpadding=0>
<tr><td>

<input type=button value="등록" OnClick="javascript:writeCheck();">

</td></tr>
</table>

만약, rails가 지원하는 RESTful 을 적용하고 form_for 등을 이용하면 위 와는 다른 코딩을 할수도 있다. 이건 추후에 다시 정리해보기로 하고 일단 pass.


# RESTful 사용시...
<div class="row">
  <div class="span6 offset3">
    <%= form_for(@rowData) do |f| %>

      <%= f.label :name %>
      <%= f.text_field :name %>

      <%= f.label :mail %>
      <%= f.text_field :mail %>

      <%= f.label :subject %>
      <%= f.text_field :subject %>

      <%= f.label :memo %>
      <%= f.text_field :memo %>

      <%= f.submit "등록", class: "btn btn-large btn-primary" %>
    <% end %>
  </div>
</div>

이제, 게시물 작성 폼까지 완성이 되었고, 등록 버튼을 클릭시 /DoWriteBoard url 처리가 필요하다.
앞서의 기능구현과 동일하게 url mapping및 컨트롤러에서의 구현, 그리고 뷰작성으로 계속 진행될것이다.

RailsBoard\config\routes.rb 에 다음처럼 mapping 해준다.

RailsBoard::Application.routes.draw do
    root :to => 'board#index'

    # 컨트롤러와 action을 mapping
    match '/show_write_form',  to: 'board#show_write_form'
    match '/DoWriteBoard',  to: 'board#DoWriteBoard'
end

그리고, action을 구현한다.
\RailsBoard\app\controllers\board_controller.rb 파일에 DoWriteBoard action을 추가한다.

class BoardController < ApplicationController
    include ApplicationHelper
    def index
        ....생략
    end

    def show_write_form
    end

    def DoWriteBoard
        @rowData = MyRailsBoardRow.new( name: params[:name], mail: params[:mail],
            subject: params[:subject], memo: params[:memo], hits:0)

        @rowData.save

        redirect_to '/'
    end
end

DoWriteBoard action에서는 폼이 전달한 인자들을 얻어서, 새로운 모델 객체를 생성한후, 실제 DB에 저장한다. 그리고 루트 화면 으로 전환한다.
잘 처리되는지 확인하기 위해서 웹페이지에서 글쓰기를 몇번 시도해보자.

그림 2 !!!!

여기서, 페이지 처리를 위한 action 을 정의하려 한다.
사용자가 page 1,2,3 등을 클릭시에 그에 맞는 처리를 해줘야하기 때문이다.
index.html.erb에서 이처리를 위해서 \listSpecificPageWork url로 처리하게 해주었다. 이를 구현한다.
match '/listSpecificPageWork', to: 'board#listSpecificPageWork' 를 route.rb에 추가한다.

RailsBoard::Application.routes.draw do
    root :to => 'board#index'

    # 컨트롤러와 action을 mapping
    match '/show_write_form',  to: 'board#show_write_form'
    match '/DoWriteBoard',  to: 'board#DoWriteBoard'
    match '/listSpecificPageWork', to: 'board#listSpecificPageWork'
end

RailsBoard\app\controllers\board_controller.rb 파일에 listSpecificPageWork action을 추가한다.

class BoardController < ApplicationController
    include ApplicationHelper

    def index
        ....생략
    end

    def show_write_form
    end

    def DoWriteBoard
        .....생략
    end

    def listSpecificPageWork
        @current_page = params[:current_page]
        @totalCnt = MyRailsBoardRow.all.count
        @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)

        # 페이지를 가지고 범위 데이터를 조회한다 => raw SQL 사용
        #Oracle 사용시
        # @boardList = MyRailsBoardRow.find_by_sql ["SELECT Z.* FROM(SELECT X.*, ceil( rownum / %s ) \
        #     as page FROM ( SELECT ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
        #         FROM MY_RAILS_BOARD_ROWS  ORDER BY ID DESC ) X ) Z WHERE page = %s", rowsPerPage, @current_page]

        #sqlite3 사용시
        @boardList = MyRailsBoardRow.find_by_sql ["select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
                from MY_RAILS_BOARD_ROWS ORDER BY id desc limit %s offset %s",
                rowsPerPage, @current_page.to_i ==1 ? 0 : 2*(@current_page.to_i-1) ]
    end
end

listSpecificPageWork action 은 페이지를 전달받아서 해당 페이지 게시물만을 목록에 출력한다.
Oracle에서는 rownum을 이용했고, sqlite 에서는 이를 대체하기 위해 limit ~ offset ~ 을 사용했다.

이제 뷰를 구현한다.
\RailsBoard\app\views\board\ 에 새로운 파일, listSpecificPageWork.html.erb 를 생성하고 내용은 다음처럼 작성해준다.

<table cellspacing=1 width=700 border=0>
    <tr>
        <td>총 게시물수: <%=@totalCnt%></td>
        <td><p align=right> 페이지:<%=@current_page%>
        </td>
    </tr>
</table>

<table cellspacing=1 width=700 border=1>
    <tr>
        <td width=50><p align=center>번호</p>
        </td>
        <td width=100><p align=center>이름</p>
        </td>
        <td width=320><p align=center>제목</p>
        </td>
        <td width=100><p align=center>등록일</p>
        </td>
        <td width=100><p align=center>조회수</p>
        </td>
    </tr>

    <% if @boardList.any? %>
        <ul>
            <%  @boardList.each do |boardRow| %>
            <tr>
            <td width=50><p align=center><%=boardRow.id%></p></td>
            <td width=100><p align=center><%=boardRow.name%></p></td>
            <td width=320>
                <p align=center>
                    <a href="/viewWork?id=<%=boardRow.id%>&current_page=<%=@current_page%>&searchStr=None" title="<%=boardRow.memo%>"><%=boardRow.subject %>
                </p>
            </td>
            <td width=100><p align=center><%=boardRow.created_at%></p></td>
            <td width=100><p align=center><%=boardRow.hits%></p></td>
            </tr>
            <% end %>
        </ul>
    <% else %>
        <p>No Data.</p>
    <% end %>
</table>

<table cellspacing=1 width=700 border=1 >
    <tr>
        <td>
        <%  @totalPageList.each do |page| %>
            <a href="/listSpecificPageWork?current_page=<%=page%>" >
            [
            <!-- Fixnum 과 String 을 비교하기 위해서 변환 -->
            <% if page == @current_page.to_i %>
                <b>
            <% end %>

            <%=page%>

            <% if page == @current_page.to_i %>
                </b>
            <% end %>
            ]
         <% end %>
        </td>
    </tr>
</table>

<table width=700>
    <tr>
        <td><input type=button value="글쓰기"  OnClick="window.location='/show_write_form'">    </td>
        <td><form name=searchf method=post action="/searchWithSubject/">
            <p align=right><input type=text name=searchStr size=50  maxlength=50>
            <input type=submit value="글찾기"></p>
        </td>
    </tr>
</table>

그런데, 이 뷰의 내용은 이미 작성한 index.html.erb와 동일하다.
그래서 기존 작성된 내용에 대해서 약간 수정을 해보기로 한다.
index action은 다음처럼 변경 가능하다.

	def index
        #@boardList = MyRailsBoardRow.find(:all, :limit => rowsPerPage, :order=> 'created_at desc')
        #@totalCnt = MyRailsBoardRow.all.count
        #@current_page = 1
        #@totalPageList = getTotalPageList(@totalCnt, rowsPerPage)

        # listSpecificPageWork 로 redirect 한다.
        url = '/listSpecificPageWork?current_page=1'
        redirect_to url
    end

그리고 기존의 index.html.erb 은 중복되므로 삭제해버리자.
테스트를 위해서 메인 페이지가 제대로 표시되는지 여부 및 페이지 전환이 정상인지 확인한다.

그럼 이제 게시물 내용보기 기능을 구현한다.
match '/viewWork',  to: 'board#viewWork' 를 route.rb에 추가한다.

RailsBoard::Application.routes.draw do
    root :to => 'board#index'

    # 컨트롤러와 action을 mapping
    match '/show_write_form',  to: 'board#show_write_form'
    match '/DoWriteBoard',  to: 'board#DoWriteBoard'
    match '/listSpecificPageWork', to: 'board#listSpecificPageWork'
    match '/viewWork',  to: 'board#viewWork'
end

그리고, action을 구현한다.
\RailsBoard\app\controllers\board_controller.rb 파일에 viewWork action을 추가한다.

class BoardController < ApplicationController
    include ApplicationHelper
    def index
        ....생략
    end

    def show_write_form
    end

    def DoWriteBoard
        ....생략
    end

	def listSpecificPageWork
		....생략
	end

    def viewWork
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr= params[:searchStr]
        MyRailsBoardRow.increment_counter(:hits, @id ) # hits increase
        @rowData = MyRailsBoardRow.find(params[:id])
    end
end

조회수를 증가하기 위해서 모델의 increment_counter 메서드를 이용했다.
그리고, 내용보기 화면에서 사용할 모델 객체 @rowData를 모델의 find class 메서드를 이용해서 구한다.
그럼 다음은, view를 추가해야한다. \RailsBoard\app\views\board\ 에 새로운 파일, viewWork.html.erb 를 생성하고 내용은 다음처럼 작성해준다.

<% provide(:title, '글보기'+@rowData.name) %>

<script language="javascript">
    function boardlist()
    {
        var s = "<%=@searchStr%>";

        if(s=="None")
            location.href = '/listSpecificPageWork?current_page=<%=@current_page%>';
        else
            location.href = '/listSearchedSpecificPageWork?pageForView=<%=@current_page%>&searchStr=<%=@searchStr%>';
    }
    function boardmodify()
    {
        location.href='/listSpecificPageWork_to_update?id=<%=@id%>&current_page=<%=@current_page%>&searchStr=<%=@searchStr%>';
    }
    function boarddelete()
    {
        location.href='/DeleteSpecificRow?id=<%=@id%>&current_page=<%=@current_page%>';
    }
</script>

<table cellspacing = 0 cellpadding = 5 border = 1 width=500>
    <tr><td><b>조회수</b></td><td><%=@rowData.hits%> </td></tr>
    <tr><td><b>이름 </b></td><td><%=@rowData.name%> </td></tr>
    <tr><td><b>이메일 </b></td><td><%=@rowData.mail%> </td></tr>
    <tr><td><b>제목 </b></td><td><%=@rowData.subject%> </td></tr>
    <tr><td><b>내용 </b></td><td width=350><%=@rowData.memo%> </td></tr>
</table>

<table  cellspacing = 0 cellpadding = 0 border = 0 width=500>
    <tr><td>
        <input type=button value="수정" OnClick="javascript:boardmodify()">
        <input type=button value="목록" OnClick="javascript:boardlist()">
        <input type=button value="삭제" OnClick="javascript:boarddelete()">
    </td></tr>
</table>

여기까지 완료후 테스트를 해보자,. 게시물중 하나를 선택하면 내용이 보일것이다.
이제 남은 기능은 게시물 수정, 삭제, 검색, 목록으로 돌아가기 등인데,
여기까지 코딩하다보면, 현재까지 매우 루틴한 작업이 반복되고 있음을 알수 있다.
그래서 남은 기능구현은 소스코드를 참고해도 충분할것같아 여기서 이만 마무리 하자.
향후 동일한 게시판 만들기를 주제로, Rails 가 제공하는 기능들을 잘 활용해서 다시 작성해보기로 한다.

################################################################################
more rails way

Ruby on Rails 간단 게시판 다시 만들어보기.

https://github.com/jeremyko/RailsBoardSample/tree/moreRailsWay

앞서 예제를 좀더 수정해서 약간 더 개선시킨 소스이다. 추가된 부분은 다음과 같다.

1. RESTful 제공
2. form_for 를 사용해서 form 작업 간소화
3. Partial 을 사용해서 중복되는 뷰를 제거
4. bootstrap-sass 적용

1. RESTful 제공

rails가 제공하는 resources 메서드를 호출해서 RESTful한 route를 사용할수 있다.
route.rb 파일을 다음처럼 변경한다.
#http://apidock.com/rails/ActionDispatch/Routing/Mapper/Resources/resources

* route.rb
RailsBoard::Application.routes.draw do       
    root :to => 'my_rails_board_rows#index'
   
    #REST-style URI    
    resources :my_rails_board_rows
    
    #matchs...
    match '/listSpecificPageWork',  to: 'my_rails_board_rows#listSpecificPageWork'    
    match '/searchWithSubject',  to: 'my_rails_board_rows#searchWithSubject'    
    match '/EditViaPostReq',  to: 'my_rails_board_rows#EditViaPostReq'   
end

이렇게 한줄 추가함으로서 rails에서 처리가능한 route는 다음처럼 구성되게 된다.

< Table 1 RESTful URI >
# -------------------------------------------------------------------------
# request   URI                         Action   Purpose
# -------------------------------------------------------------------------
# GET       /my_rails_board_rows        index    모든 게시물들 조회
# GET       /my_rails_board_rows/1      show     id 1의 게시물 조회
# GET       /my_rails_board_rows/new    new      새로운 게시물 작성을 위한 화면 보임
# POST      /my_rails_board_rows        create   새로운 게시물을 생성 처리
# GET       /my_rails_board_rows/1/edit edit     id 1 게시물 수정을 위한 화면 보임
# PUT       /my_rails_board_rows/1      update   id 1 게시물 수정 작업 처리
# DELETE    /my_rails_board_rows/1      destroy  id 1 게시물 삭제 처리

게시물 CRUD 처리를 RESTful하게 처리하기 때문에, 이전 예제와 비교시 action이 간단해졌다. 현재 사용가능한 route정보는 rake routes 명령을 이용해서 언제나 알아볼수 있다.

D:\Ruby_Dev\RailsBoard>rake routes
                   root        /                                       my_rails_board_rows#index
    my_rails_board_rows GET    /my_rails_board_rows(.:format)          my_rails_board_rows#index
                        POST   /my_rails_board_rows(.:format)          my_rails_board_rows#create
 new_my_rails_board_row GET    /my_rails_board_rows/new(.:format)      my_rails_board_rows#new
edit_my_rails_board_row GET    /my_rails_board_rows/:id/edit(.:format) my_rails_board_rows#edit
     my_rails_board_row GET    /my_rails_board_rows/:id(.:format)      my_rails_board_rows#show
                        PUT    /my_rails_board_rows/:id(.:format)      my_rails_board_rows#update
                        DELETE /my_rails_board_rows/:id(.:format)      my_rails_board_rows#destroy
   listSpecificPageWork        /listSpecificPageWork(.:format)         my_rails_board_rows#listSpecificPageWork
      searchWithSubject        /searchWithSubject(.:format)            my_rails_board_rows#searchWithSubject
         EditViaPostReq        /EditViaPostReq(.:format)               my_rails_board_rows#EditViaPostReq

또한 Rails는 url을 간단하게 표시할수 있게끔 helper를 같이 생성해주는데, resources :my_rails_board_rows 의 경우 다음과 같은 helper들이 생성된다.

    ----------------------------------------------------------------
    helper                              호출시 return 되는 값
    ----------------------------------------------------------------
    my_rails_board_rows_path            /my_rails_board_rows
    new_my_rails_board_row_path         /my_rails_board_rows/new
    edit_my_rails_board_row_path(:id)   /my_rails_board_rows/:id/edit
    my_rails_board_row_path(:id)        /my_rails_board_rows/:id

* my_rails_board_rows_controller.rb

RESTful 구현을 위해 컨트롤러를 작성해보자
resources 호출로  RSESTful한 접근을 설정한 경우, Rails 는 위에서 표시된 것처럼(예를 들어, my_rails_board_rows#new), 모델명을 기준으로 컨트롤러를 찾게 된다. 즉, my_rails_board_rows_controller.rb를 찾는데, 현재 이 파일이 없으므로 생성해줘야 한다.
 
rails g controller my_rails_board_rows 을 수행하거나, 직접 파일을 생성해도 된다.
그리고 다음처럼 코딩한다. 

class MyRailsBoardRowsController < ApplicationController
    include ApplicationHelper

    def index
        @searchStr = 'None'
        @totalCnt = MyRailsBoardRow.all.count                  
        @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)        
        @boardList = 
                MyRailsBoardRow.find_by_sql ["select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
                    from MY_RAILS_BOARD_ROWS ORDER BY id desc limit %s offset 0", rowsPerPage ] 

        render 'listSpecificPageWork' 
    end
    
    def show
        # 내용보기 구현
        @id = params[:id]
        @current_page = params[:current_page] 
        @searchStr= params[:searchStr]                 
        # hits increase        
        MyRailsBoardRow.increment_counter(:hits, @id  )
        @rowData = MyRailsBoardRow.find(params[:id])
        render 'viewWork'  
    end
    
    def new
        # 새로운 게시물 생성 구현
        @rowData = MyRailsBoardRow.new 
        render 'show_write_form'
    end
    
    def create
        # 글쓰기 등록 구현
        @rowData = MyRailsBoardRow.new(params[:my_rails_board_row])
                
        if @rowData.save          
          redirect_to '/'
        else
          render 'show_write_form'
        end
    end
        
    def update
        # 변경내용을 저장 구현
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr = params[:searchStr] 
        
        # Update DataBase
        @rowData = MyRailsBoardRow.find(params[:id])      

        if @rowData.update_attributes(params[:my_rails_board_row])
            # Display Page => POST 요청은 redirection!
            url = '/listSpecificPageWork?current_page=' + @current_page+'&searchStr='+@searchStr
            redirect_to url     
        else
            render 'update'
        end        
    end
    
    def destroy
        # 게시물 삭제 구현
        MyRailsBoardRow.find(params[:id]).destroy
                
        redirect_to my_rails_board_rows_path
    end    
    
    def EditViaPostReq
        # 내용 수정을 위해 내용 출력 구현
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr = params[:searchStr] 
        @rowData = MyRailsBoardRow.find(params[:id])

        render 'update'
    end

    def searchWithSubject
        @searchStr = params[:searchStr]                        
        url = '/listSpecificPageWork?searchStr=' + @searchStr +'&current_page=1'
        Rails.logger.debug "***** url:" + url
        
        uri = URI.encode(url.strip) # 한글로 검색하는 경우를 위해, encode해준다.     
        Rails.logger.debug uri
        
        redirect_to uri
    end    
    
    def listSpecificPageWork

        @searchStr = URI.decode(params[:searchStr]) # 한글로 검색하는 경우를 위해, decode해준다.     
        Rails.logger.debug "listSpecificPageWork: @searchStr=" + @searchStr        
        @current_page = params[:current_page]                 
        Rails.logger.debug "!!! searchStr: #{@searchStr}"     
                                
        if @searchStr == 'None'
            @totalCnt = MyRailsBoardRow.all.count                  
            @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)
            
            #sqlite3         
            @boardList = 
                MyRailsBoardRow.find_by_sql ["select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
                    from MY_RAILS_BOARD_ROWS ORDER BY id desc limit %s offset %s", 
                    rowsPerPage, @current_page.to_i ==1 ? 0 : 2*(@current_page.to_i-1) ] 
        else
            # 검색처리
            @totalCnt = MyRailsBoardRow.where("subject LIKE ?","%#{@searchStr}%").count() 
            @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)
            @boardList = 
                MyRailsBoardRow.find_by_sql [
            "select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS from MY_RAILS_BOARD_ROWS where subject like '%%%s%%' ORDER BY id desc
             limit %s offset %s", @searchStr,rowsPerPage, @current_page.to_i ==1 ? 0 : 2*(@current_page.to_i-1) ] 
         end
    end
end

이전 예제와 비교해서 달라진 점은 다음과 같다.

- RESTful 처리로 인해 이름이 변경되거나 삭제된 method

show_write_form                 => new
DoWriteBoard                    => create
viewWork                        => show
listSpecificPageWork_to_update  => EditViaPostReq
updateBoard                     => update
DeleteSpecificRow               => destroy
listSearchedSpecificPageWork    => 삭제됨,listSpecificPageWork로 통합

다소 중복되었던 기능 통합을 위해 listSearchedSpecificPageWork 메서드는 listSpecificPageWork 로 통합되었다.
이전 예제에서는 컨트롤러의 action 명에 맞는 view template 를 자동으로 찾아갈수 있게끔 처리했지만(rails 규칙), 이제 action명이 RESTful 한 것으로 변경되었으므로, render 를 이용해서 명시적으로 뷰를 지정해 준다. 그런데 EditViaPostReq action은 왜 사용했을까? RESTful 구현을 위해서는 edit 라는 action을 정의해야 할것 같은데 말이다. 이것은 나중에 보게 되겠지만, 뷰에서 button_to 를 이용해서 변경할 내용을 가져오게 처리했기 때문이다. 나중에 뷰를 작성할때 다시 알아보기로 하고, 일단은 edit를 RESTful하게 처리하려면 GET방식으로 호출을 해야함을 기억하자 (위 < Table 1 RESTful URI > 도표를 참조). 그리고 이전 예제와 비교시 중요한 차이점은 새로운 게시물을 생성할때 모델을 생성해서 넘긴다는 점이다.
즉, @rowData = MyRailsBoardRow.new 이부분이다. 이전 예제에서는 신규 작성 화면에서 넘겨준 내용을 컨트롤러에서 찾아서 새로운 모델을 생성해서 저장했었다. 이부분을 모델을 먼저 생성해서 뷰에 전달하고 돌려받는 식으로 깔끔하게 처리할수 있게 변경한 것이다. 

그럼 새로운 글을 작성하기 위한 뷰를 정의해보자. 
그전에 먼저 listSpecificPageWork.html.erb 파일 내용을 다음처럼 변경한다. 중복되던 소스를 통합한 소스이다.

* listSpecificPageWork.html.erb

<table cellspacing=1 width=700 border=0>
    <tr>
        <td>총 게시물수: <%=@totalCnt%></td>
        <td><p align=right> 페이지:<%=@current_page%></td>        
    </tr>
</table>

<table cellspacing=1 width=700 border=1>
    <tr>
        <td width=50><p align=center>번호</p></td>
        <td width=100><p align=center>이름</p></td>
        <td width=320><p align=center>제목</p></td>
        <td width=100><p align=center>등록일</p></td>
        <td width=100><p align=center>조회수</p></td>
    </tr>
    
    <% if @boardList.any? %>
        <ul>            
            <%  @boardList.each do |boardRow| %>
            <tr>
            <td width=50><p align=center><%=boardRow.id%></p></td>
            <td width=100><p align=center><%=boardRow.name%></p></td>                
            <td width=320>
                <p align=center>
                    <a href="/my_rails_board_rows/<%=boardRow.id%>?current_page=<%=@current_page%>&searchStr=<%=@searchStr%>" title="<%=boardRow.memo%>"><%=boardRow.subject %> 
                </p>
            </td>                      
            <td width=100><p align=center><%=boardRow.created_at%></p></td>
            <td width=100><p align=center><%=boardRow.hits%></p></td>
            </tr>       
            <% end %>
        </ul>
    <% else %>
        <p>No Data.</p>
    <% end %>
</table>

<table cellspacing=1 width=700 border=1 >
    <tr>
        <td>      
        <%  @totalPageList.each do |page| %>
            <a href="/listSpecificPageWork?current_page=<%=page%>&searchStr=<%=@searchStr%>" >
            [            
            <% if page == @current_page.to_i %>
                <b>
            <% end %>

            <%=page%>

            <% if page == @current_page.to_i %>
                </b>
            <% end %>
            ]
         <% end %>        
        </td>
    </tr>
</table>

<% if @searchStr == 'None' %>
    <form name="searchf" method="post" action="/searchWithSubject/"> 
    <table width=700>
        <tbody>
            <tr>
                <td valign="center">
                    <p align="left"><input class="btn btn-large btn-primary" value="글쓰기" onclick="window.location='/my_rails_board_rows/new'"  type="button"></p>
                </td>
                <td valign="right">                    
                        <p align="right"><input name="searchStr" size="30" maxlength="50" type="text"></p>                    
                </td>
                <td valign="center">
                    <p align="right"><input class="btn btn-large btn-primary" value="글찾기" type="submit"></p>
                </td>
            </tr>
        </tbody>
    </table>
    </form>
<% else %>
    <table width=700>
        <tr>
            <td><input type=button class="btn btn-large btn-primary" value="전체 목록으로 돌아가기"  OnClick="window.location='/'" >         
        </tr>
    </table>
<% end %>

별로 중요한 내용은 없고, 이전 예제에서 중복 소스를 통합한 것뿐이다.
소스상에서 글작성을 위한 Action이 /my_rails_board_rows/new 인것을 확인할수 있을 것이다. 컨트롤러에서는 new액션이 호출되고, show_write_form 뷰가 호출되게 된다. 이제 글작성을 위해 뷰를 수정해보자. show_write_form.html.erb 파일이 이미 존재할것이다. 이 내용을 다음처럼 변경한다.

* show_write_form.html.erb

<% provide(:title, '게시판 글쓰기') %>

<table cellspacing = 0 cellpadding = 5 border = 1 width=500>

    <%= form_for(@rowData) do |f| %>    
        <!-- 여기서부터: 공통적으로 사용이 될법한 부분 --> 
        <tr>
            <td><b><%= f.label :name %></b></td>       
            <td><%= f.text_field :name %><br /></td>       
        </tr>
        <tr>
            <td><b><%= f.label :mail %></b></td>            
            <td><%= f.text_field :mail %><br /></td>            
        </tr>
        <tr>
            <td><b><%= f.label :subject %></b></td>            
            <td><%= f.text_field :subject %><br /></td>                        
        </tr>
        <tr>
            <td><b><%= f.label :memo %></b></td>
            <td><%= f.text_area :memo %><br /></td>            
        </tr>
        <!-- 여기까지: 공통적으로 사용이 될법한 부분 --> 

        <table width="150">
            <tr>
                <td>
                    <%= f.submit "등록", class: "btn btn-large btn-primary" %>
                </td>                
            </tr>
        </table>
    <% end %>
</table>

이전 예제에서는 직접 form을 구성하는 부분이 있었지만 이제는, 모델(Active Record)의 속성을 가지고 자동적으로 입력폼을 만들어주는 form_for helper method를 사용했다. 즉 다음의 코드는 실제 html에서는 다음으로 변환된다.

<%= f.label :name %>
<%= f.text_field :name %>

------>

<label for="my_rails_board_row_name">Name</label>
<input id="my_rails_board_row_name" name="my_rails_board_row[name]" size="30" type="text" />

또한 form_for는 새로운 form을 생성하게 되는데, 실제 생성되는 html 소스는 다음과 같다.
<form accept-charset="UTF-8" action="/my_rails_board_rows" class="new_my_rails_board_row" id="new_my_rails_board_row" method="post">

흥미로운 점은 Rails가 판단해서 새로운 글 작성시 필요한 URI, method 를 설정해 줬다는 점이다. 즉, 현재 이 뷰가 호출되게 만든 actin은 GET방식- /my_rails_board_rows/new action 이었다. 그리고 글작성 뷰에서 form 이 처리하는 action은 Rails에 의해 POST 방식- /my_rails_board_rows 액션으로 설정이 된다. 그리고 이 결과로 RESTful하게 호출되는것은 create action이 될것이다 ( Table 1 RESTful URI 에서처럼). RESTful하게 처리되게끔 Rails 가 자동으로 설정을 해주니 간편한것 같다. 그럼 다시 글작성 뷰 소스로 돌아가 보자. 곰곰 생각해보니 글 작성과 조회, 수정시에 공통적으로 사용이 될만한 부분이 보인다. 바로 이부분들이다.
<tr>
    <td><b><%= f.label :name %></b></td>       
    <td><%= f.text_field :name %><br /></td>       
</tr>
... 

rails에서는 중복되는 뷰를 공통적으로 사용할수 있게끔 partial 을 사용할수 있다.
위 소스를 다음처럼 수정한다.

<% provide(:title, '게시판 글쓰기') %>

<table cellspacing = 0 cellpadding = 5 border = 1 width=500>

    <%= form_for(@rowData) do |f| %>    
        <%= render 'shared/error_messages' %>
        <% @readOnlyFlag = 0 %>       
        <%= render :partial => "rowDataInput", :locals => { :f => f , :readOnlyFlag => @readOnlyFlag } %>                

        <table width="150">
            <tr>
                <td>
                    <%= f.submit "등록", class: "btn btn-large btn-primary" %>
                </td>                
            </tr>
        </table>
    <% end %>
</table>

rowDataInput 이라는 partial을 사용해서 중복없이 소스를 관리할수 있다. 이를 위해서는 '_' 로 시작되는 partial 파일을 생성해야 한다.
즉, _rowDataInput.html.erb 파일이다. 

* \RailsBoard\app\views\my_rails_board_rows\_rowDataInput.html.erb

    <tr>
        <td><b><%= f.label :name %></b></td>
        <% if @readOnlyFlag == 1 %>
            <td><%= f.text_field :name,:readonly => true %><br /></td>
        <% else %>
            <td><%= f.text_field :name %><br /></td>            
        <% end %>
    </tr>
    <tr>
        <td><b><%= f.label :mail %></b></td>
        <% if @readOnlyFlag == 1 %>
            <td><%= f.text_field :mail,:readonly => true %><br /></td>
        <% else %>
            <td><%= f.text_field :mail %><br /></td>            
        <% end %>        
    </tr>
    <tr>
        <td><b><%= f.label :subject %></b></td>
        <% if @readOnlyFlag == 1 %>
            <td><%= f.text_field :subject,:readonly => true %><br /></td>
        <% else %>
            <td><%= f.text_field :subject %><br /></td>            
        <% end %>        
    </tr>
    <tr>
        <td><b><%= f.label :memo %></b></td>
        <% if @readOnlyFlag == 1 %>
            <td><%= f.text_area :memo,:readonly => true %><br /></td>
        <% else %>
            <td><%= f.text_area :memo %><br /></td>            
        <% end %>        
    </tr>
    
약간 수정된 부분이 있다. readOnlyFlag 을 partial에 전달하는 목적은 글작성, 조회, 변경시에 수정가능 여부를 조정하기 위한 목적이다.
그런데 <%= render 'shared/error_messages' %> 이부분은 무었인가? 

* Validation 

이것은 입력 유효성 체크를 위해서 사용되었다. rails에서 입력 유효성을 체크하기 위해서는 모델에 validates 호출을 추가해야한다.
\Ruby_Dev\RailsBoard\app\models\my_rails_board_row.rb 파일을 다음처럼 수정한다.

class MyRailsBoardRow < ActiveRecord::Base
    attr_accessible :hits, :mail, :memo, :name, :subject

    # 유효성 체크 
    before_save { |rowData| rowData.mail = mail.downcase }
    validates :name,  presence: true, length: { maximum: 50 }
    validates :subject,  presence: true, length: { maximum: 50 }
    VALID_EMAIL_REGEX = /\A[\w+\-.]+@[a-z\d\-.]+\.[a-z]+\z/i
    validates :mail, presence: true, format: { with: VALID_EMAIL_REGEX }
    validates :memo,  presence: true, length: { maximum: 200 }
end

무엇을 의미하는지는 바로 알수 있을것 같다.
presence: true -> 설정해서 반드시 입력해야하는 값임을 설정하는것이다. 이메일 입력의 경우 유효한 이메일 주소인지 판단시 정규식을 이용할수 있다. 이제 error_messages partial 을 생성한다. 

\RailsBoard\app\views\shared\_error_messages.html.erb

<% if @rowData.errors.any? %>
  <div id="error_explanation">
    <div class="alert alert-error">
      The form contains <%= pluralize(@rowData.errors.count, "error") %>.
    </div>
    <ul>
    <% @rowData.errors.full_messages.each do |msg| %>
      <li>* <%= msg %></li>
    <% end %>
    </ul>
  </div>
<% end %>
이 partial이 하는 일은 모델에 에러가 있는 경우 모든 에러에 대한 상세 메시지를 화면에 출력해 주는 것이다.

* bootstrap

이전 예제에서 아무런 CSS처리없이 화면 처리가 되었는데, 이제 약간 화면 디자인을 고려해서 CSS를 적용해보자. bootstrap-sass gem을 설치해서 사용해 보려 한다. Gemfile에 gem 'bootstrap-sass', '2.0.4' 을 추가한다.

source 'https://rubygems.org'

gem 'rails', '3.2.8'
gem 'sqlite3', '1.3.5'
gem 'bootstrap-sass', '2.0.4'

# gem 'ruby-oci8'
# gem 'activerecord-oracle_enhanced-adapter'
group :assets do
  gem 'sass-rails',   '~> 3.2.3'
  gem 'coffee-rails', '~> 3.2.1'  
  gem 'uglifier', '>= 1.0.3'  
end

gem 'jquery-rails'

그리고 bundle install 을 수행해서 설치한다.
그다음 해야 할일은 app/assets/stylesheets/custom.css.scss 파일을 생성하는것이다. 

* custom.css.scss

@import "bootstrap";

$grayMediumLight: #eaeaea;

html {
  overflow-y: scroll;
}

body {
  padding-top: 60px;
  background-color:$grayMediumLight;  
}

section {
  overflow: auto;
}

.center {
  text-align: center;
}

.center h1 {
  margin-bottom: 10px;
}

@mixin box_sizing {
  -moz-box-sizing: border-box; 
  -webkit-box-sizing: border-box; 
  box-sizing: border-box;
}

/* forms */
textarea
{
  border: 1px solid #bbb;
  width: 100%;
  padding: 5px;
  height: 100px;
  margin-bottom: 5px;
  @include box_sizing;

  resize: vertical;  
}

input
{
  border: 1px solid #bbb;
  width: 100%;
  padding: 5px;
  height: auto;
  margin-bottom: 5px;
  @include box_sizing;  
}

#error_explanation
{
  color: #f00;
  ul {
    list-style: none;
    margin: 0 0 5px 0;
  }
}

.field_with_errors 
{
  @extend .control-group;
  @extend .error;      
}

* Test
여기까지 작업후, 테스트를 해본다. 서버를 기동시킨후, localhost:3000 로 가보면 화면이 약간 이쁘게 변한것을 볼수 있을것이다. 
그림 1

아까 만든 유효성 체크를 위해 글작성 화면으로 가서, 아무 내용없이 등록 버튼을 눌러 보자. 
그림 2

다음 처럼 상세 에러메시지가 보이게 된다.
그림 3

정상적으로 입력후 등록 버튼을 누르면 저장이 될것이다.

이제 글 조회를 위한 기능을 처리해보자. 메인 뷰에서 글 제목을 선택사, 다음 link로 이동하게 된다.

<a href="/my_rails_board_rows/<%=boardRow.id%>?current_page=<%=@current_page%>&searchStr=<%=@searchStr%>" title="<%=boardRow.memo%>"><%=boardRow.subject %> 
or
<%= link_to boardRow.subject, my_rails_board_row_path(:id => boardRow.id, :current_page=>@current_page, :searchStr=>@searchStr), :method => :get %>


* BDD using RSpec



////////////////////////////////////////////////////////////////////////////////
class MyRailsBoardRowsController < ApplicationController
    include ApplicationHelper

    def index
        # 좀더 RESTful
        @searchStr = 'None'
        @totalCnt = MyRailsBoardRow.all.count                  
        @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)        
        @boardList = 
                MyRailsBoardRow.find_by_sql ["select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
                    from MY_RAILS_BOARD_ROWS ORDER BY id desc limit %s offset 0", rowsPerPage ] 

        render 'listSpecificPageWork' 
    end
    
    def show
        # 내용보기
        @id = params[:id]
        @current_page = params[:current_page] 
        @searchStr= params[:searchStr] 
                
        # hits increase        
        MyRailsBoardRow.increment_counter(:hits, @id  )

        @rowData = MyRailsBoardRow.find(params[:id])      

        render 'viewWork'  
    end
    
    def new
        # 새로운 게시물 생성, 명시적으로 view를 지정한다. (기본적으로 new.html.erb를 참조함)
        @rowData = MyRailsBoardRow.new 
        render 'show_write_form'
    end
    
    def create
        # 글쓰기 등록
        @rowData = MyRailsBoardRow.new(params[:my_rails_board_row])
                
        if @rowData.save          
          redirect_to '/'
        else
          render 'show_write_form'
        end
    end
        
    def edit
        # 내용 수정을 위해 내용 출력하기        
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr = params[:searchStr] 
        @rowData = MyRailsBoardRow.find(params[:id])
        render 'update'
    end

    def update
        # 변경내용을 저장할때
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr = params[:searchStr] 
        
        # Update DataBase
        @rowData = MyRailsBoardRow.find(params[:id])      

        if @rowData.update_attributes(params[:my_rails_board_row])
            # Display Page => POST 요청은 redirection!
            url = '/listSpecificPageWork?current_page=' + @current_page+'&searchStr='+@searchStr
            redirect_to url     
        else
            render 'update'
        end        
    end
    
    def destroy
        # 게시물 삭제
        Rails.logger.debug "current_page: #{params[:current_page]}"     

        MyRailsBoardRow.find(params[:id]).destroy
                
        redirect_to my_rails_board_rows_url
    end    
    
    def EditViaPostReq
        # 내용 수정을 위해 내용 출력하기        
        @id = params[:id]
        @current_page = params[:current_page]
        @searchStr = params[:searchStr] 
        @rowData = MyRailsBoardRow.find(params[:id])

        render 'update'
    end

    def searchWithSubject

        @searchStr = params[:searchStr]                        
        url = '/listSpecificPageWork?searchStr=' + @searchStr +'&current_page=1'
        Rails.logger.debug "***** url:" + url
        
        uri = URI.encode(url.strip) # 한글로 검색하는 경우를 위해, encode해준다.     
        Rails.logger.debug uri
        
        redirect_to uri
    end    
    
    def listSpecificPageWork

        @searchStr = URI.decode(params[:searchStr])           
        Rails.logger.debug "listSpecificPageWork: @searchStr=" + @searchStr
        
        @current_page = params[:current_page]         
        
        Rails.logger.debug "!!! searchStr: #{@searchStr}"     
                                
        if @searchStr == 'None'
            @totalCnt = MyRailsBoardRow.all.count                  
            @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)
            #sqlite3         
            @boardList = 
                MyRailsBoardRow.find_by_sql ["select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS \
                    from MY_RAILS_BOARD_ROWS ORDER BY id desc limit %s offset %s", 
                    rowsPerPage, @current_page.to_i ==1 ? 0 : 2*(@current_page.to_i-1) ] 
        else
            # 검색처리
            @totalCnt = MyRailsBoardRow.where("subject LIKE ?","%#{@searchStr}%").count() 
            @totalPageList = getTotalPageList( @totalCnt, rowsPerPage)
            @boardList = 
                MyRailsBoardRow.find_by_sql [
            "select ID,SUBJECT,NAME, CREATED_AT, MAIL,MEMO,HITS from MY_RAILS_BOARD_ROWS where subject like '%%%s%%' ORDER BY id desc
             limit %s offset %s", @searchStr,rowsPerPage, @current_page.to_i ==1 ? 0 : 2*(@current_page.to_i-1) ] 
         end
    end
end